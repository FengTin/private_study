基础：
	排序：
	var arr = [21,34,23,54,65,78];
		for(var i = 0;i<arr.length;i++){
			for(var j = 0;j<arr.length;j++){
				if(arr[j]>arr[j+1]){
					var res = arr[j]
					arr[j] = arr[j+1]
					arr[j+1] = res;
				}
			}
		}
		console.log(arr);	
	选择排序：
			var arr = [21,34,23,54,65,78];
		for(var i = 0;i<arr.length;i++){
			for(var j = 0;j<arr.length;j++){
				if(arr[i]<arr[j]){
					var res = arr[i]
					arr[i] = arr[j]
					arr[j] = res;
				}
			}
		}
	二分法排序（递归）：
		递归的思想： 递归注重的是结果   不是过程
			var arr = [21,34,23,54,65,78];
			function quick(arr){
				if(arr.length <= 1){
					return arr;
				}
				var index = parseInt(arr.length/2);
				var mid = arr[index];
				var left = [];
				var right = [];
				for(var i = 0;i<arr.length;i++){
					if(i==index) {
						continue
					}
					if(arr[i]>mid){
						left.push(arr[i])
					}else{
						right.push(arr[i])
					}
				}
				return quick(right).concat(mid).concat(quick(left));
			}
	预解析：(执行期 和 编译期---（预解析）)
		提升当前作用域的最上面！！！
		形参与变量名重名  以形参为主
		实参大于形参：  多余的实参忽略
		形参大于实参：  多余的形参赋值与undefined
		1.变量的提升
		2.函数名提升
		3.分配栈堆地址
		4.生成对应的哈希
			加密（不同的密文要对应不同的秘钥   一一对应）
		5.确定事件流的路线
	函数：
		全局函数调用
		方法调用
		上下文调用（环境调用）   call   bind   apply
	函数的执行过程：
		1.当发现函数会推送到执行环境（环境执行栈）
		2.当去调用 会把执行过后的代码（返回）主栈
		3.如果没有return  返回的是默认执行环境下的undefined
		4.如果发现有形参 和 变量  会把变量 与形参保存在当前执行环境
	函数查找的规则
		作用域链：
			1.现在当前执行环境下查找
			2.在向上一级查找
			3.。。。。。
		局部变量与全局变量的区别：
			1.局部环境可以访问全局全局环境不可以访问局部环境
			2.垃圾回收机制：
				计数清除   255   305
				标记清除  标记计数   准备删除的时候  要查看当前的变量是否存在引用（闭包）
		事件的处理机制：
			1.预解析会确定事件流的路线
			2.单击事件的时候 根据事件路线 向里面依次触发事件
			3.达到最里层之后 执行向外的冒泡
			4.最里层的元素不分顺序谁先定义执行谁；
			5.事件流跟位置没有关系跟包含与被包含有关系
	编程：
		面向过程
		面向对象
		函数式（链式编程  jq）
	面向对象：
		对象： 
			1.键值对的映射
			2.属性与方法的集合
	面向过程：
		看中的是过程  注重的是每一步
			面向过程：1.找演员----找设备----找吃的----找陪的-----抽奖！
	面向对象：
		看中的是对象  注重的是结果（模块）
			面向对象： 1.
			var obj = {
				张三:function(){
					......
				},
				李四:function(){
					.....
				}
			}
		好处：
			模块化开发
			提高效率
			好用方便

	

	闭包：
		什么是闭包：
			1.一个作用域可以访问另一个作用域的变量;
			2.一个函数引用父级环境的变量 并且把这个函数内部的变量 返回更高的环境
		为什么要使用闭包：
			闭包：
				占用内存
				不容易释放空间
			好处：
				确保变量不被销毁
		闭包有什么特点
			 1.内部要返回函数
			 2.要引用外部的变量
		如何使用闭包
				// for(var i = 0;i<10;i++){
				// 	(function(i){
				// 		setTimeout(function(){
				// 			console.log(i)
				// 		})
				// 	})(i)
				// }
		伪数组与数组：
			伪数组具有数组的一些属性  也不具有数组的一些方法
			伪数组 用for in 遍历 会遍历出 不知道的函数
			伪数组转化数组：
				var p1 = Array.prototype.slice.call(p);
				for(var k in p1){
					console.log(p1[k])
				}
			call  apply  bind
			1.改变this指向
			2.在不同环境下执行
			
			function A(name,age){
				this.name = name;
				this.age = age;
			}
			A.prototype.fn = function(){
				console.log(123)
			}
			function B(name,age,id){
				this.id = id;
				A.call(this,name,age)
			}
			//A的原型=B的原型
			B.prototype = A.prototype;
			function C(name,age,sex){
				this.sex = sex;
				A.apply(this,[name,age])
			}
			C.prototype = A.prototype;
			C.prototype.fn = function(){
				console.log(456)
			}
			var b = new B("kf",12);
			b.fn()	
		canvas：
			这个玩意是画图的
				function React(options){
				this.init(options)
			}
			React.prototype={
				init:function(options){
					this.x = options.x;
					this.y = options.y;
					this.width = options.width||100;
					this.height = options.height||100;
					this.bgcolor = options.bgcolor||"pink";
					this.border = options.color;
					this.linewidth = options.linewidth||5;
				},
				renderrect:function(ctx){
					ctx.rect(this.x,this.y,this.width,this.height);
					ctx.fillStyle = this.bgcolor;
					ctx.fill();
					ctx.stroke()
				},
				renderarc:function(ctx){
					ctx.arc(100,100,50,0*Math.PI,2*Math.PI,true);
					ctx.fillStyle = this.bgcolor;
					ctx.fill();
					ctx.stroke()
				}
			}


			var rect = new React({
				x:100,
				y:100,
				width:100,
				height:100,
				bgcolor:"pink"

			});
			rect.renderarc(ctx);
			rect.renderrect(ctx);
